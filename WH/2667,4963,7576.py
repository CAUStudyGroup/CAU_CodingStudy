# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BYl8uJHv0a8rIEwHOXcgUXd_K8X5K4Lg
"""

#2667 dfs
import sys
read = lambda : sys.stdin.readline().strip()

n = int(read())

def dfs(matrix, cnt, x,y):
    matrix[x][y]=0
    # 이건 이제 이미 간것이다. 하고 0으로 바꾸는것 이다.
    dx = [1,-1,0,0]
    dy = [0,0,1,-1]
    for i in range(4):
        n_x = x + dx[i]
        n_y = y + dy[i]
        # 이 근처 다 n_x, n_y로 간다.
        if n_x>=0 and n_x<n and n_y>=0 and n_y<n:
            # 범위 check
            if matrix[n_x][n_y]==1:
            # 그부분이 1이면
                cnt = dfs(matrix, cnt+1, n_x, n_y)
                # cnt를 증가시켜서 다시한번 그 근처 확인
    return cnt
    # 다 cnt검사하면 끝을 낸다.

matrix = [list(map(int, list(read()))) for _ in range(n)]
# matrix에 input값 넣기

ans = []
for i in range(n):
    for j in range(n):
        if matrix[i][j]==1:
            # 일단 1로 뭔가의 그룹이다.
            ans.append(dfs(matrix, 1, i, j))

print(len(ans))
for i in sorted(ans):
    print(i)

#2667 bfs 
import sys
read = lambda : sys.stdin.readline().strip()

n = int(read())

dx = [1,-1,0,0]
dy = [0,0,1,-1]

def bfs(matrix, cnt, x, y):
    matrix[x][y]=0
    # 이건 이제 이미 간것이다. 그래서 0으로 바꾼다
    queue = []
    queue.append((x, y))
    while len(queue) > 0:
        x, y = queue.pop()
        for k in range(0, 4):
            nx, ny = x + dx[k], y + dy[k]
            if 0 <= nx and nx< n and 0<= ny and ny <n:
                if matrix[nx][ny] == 1:
                    cnt += 1
                    matrix[nx][ny] = 0
                    queue.append((nx, ny))
    return cnt

matrix = [list(map(int, list(read()))) for _ in range(n)]
# matrix에 input값 넣기

cnt = 0
ans = []
for i in range(n):
    for j in range(n):
        if matrix[i][j]==1:
            # 일단 1로 뭔가의 그룹이다.
            ans.append(bfs(matrix, cnt+1, i, j))
            # 여기서 이제 그 주위에 있는 것들 다 돌아보는것이다.
print(len(ans))
for i in sorted(ans):
    print(i)

#4963   dfs로만 풀었음 bfs 못함
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline()

dx = (-1, -1, -1, 0, 1, 1, 1, 0)
dy = (-1, 0, 1, 1, 1, 0, -1, -1)

while True:
    w, h = map(int, input().split())
    if not w:
        break
    a = [list(map(int, input().split())) for _ in range(h)]
    check = [[False]*w for _ in range(h)]

    def dfs(x, y):
        check[x][y] = True
        for i in range(8):
            nx, ny = x+dx[i], y+dy[i]
            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                continue
            if a[nx][ny] == 1 and check[nx][ny] is False:
                dfs(nx, ny)

    cnt = 0
    for i in range(h):
        for j in range(w):
            if a[i][j] == 1 and check[i][j] is False:
                dfs(i, j)
                cnt += 1
    print(cnt)

#7576 bfs

from collections import deque

flag = 0
def bfs(graph, start_point, box_row, box_col): #graph는 2차원 배열 형태
    global flag
    j = i = 0
    day = [[0]*box_col for x in range(box_row)]
    while start_point: #start_point는 queue의 형태
        n = start_point.popleft()
        j,i = n[0],n[1]
        for y,x in (j+1,i),(j,i+1),(j-1,i),(j,i-1):
            if 0<=y<box_row and 0<=x<box_col:
                if graph[y][x]:
                    continue
                graph[y][x] = 1
                day[y][x] = day[j][i] + 1
                start_point += [[y,x]]
                flag -= 1
    if flag:
        return -1
    return day[j][i]

q = deque()
box_size = input().strip().split()
col, row = int(box_size[0]) , int(box_size[1])
tomato = [[-1]*1000 for x in range(1000)]

for y in range(row):
    val = input().strip().split()
    for x in range(col):
        tomato[y][x] = int(val[x])
        if int(val[x]) == 1: #1들어간 인덱스 start_point에 저장
            q+=[[y,x]]
        elif not int(val[x]): #0일때의 개수
            flag += 1

#토마토가 다 익어있으면 0 출력(입력에 1 or -1만 있는 경우)
#토마토가 다 익을수 없는상황이면 -1 출력
#토마토가 다익는 일 수 출력
print(bfs(tomato, q, row, col))